// Generated by dts-bundle v0.2.0

declare module 'ts-events' {
    import syncEvent = require("__ts-events/lib/sync-event");
    export import SyncEvent = syncEvent.SyncEvent;
    export import VoidSyncEvent = syncEvent.VoidSyncEvent;
    export import ErrorSyncEvent = syncEvent.ErrorSyncEvent;
    import queuedEvent = require("__ts-events/lib/queued-event");
    export import QueuedEvent = queuedEvent.QueuedEvent;
    export import VoidQueuedEvent = queuedEvent.VoidQueuedEvent;
    export import ErrorQueuedEvent = queuedEvent.ErrorQueuedEvent;
    import asyncEvent = require("__ts-events/lib/async-event");
    export import AsyncEvent = asyncEvent.AsyncEvent;
    export import VoidAsyncEvent = asyncEvent.VoidAsyncEvent;
    export import ErrorAsyncEvent = asyncEvent.ErrorAsyncEvent;
    export import EventQueue = require("__ts-events/lib/EventQueue");
    /**
        * Convenience function, same as EventQueue.global().flushOnce().
        * Flushes the QueuedEvents, calling all events currently in the queue but not
        * any events put into the queue as a result of the flush.
        */
    export function flushOnce(): void;
    /**
        * Convenience function, same as EventQueue.global().flush().
        * Flushes the QueuedEvents, calling all handlers currently in the queue and those
        * put into the queue as a result of the flush.
        * @param maxRounds Optional, default 10. Number of iterations after which to throw an error because
        *                  the queue keeps filling up. Set to undefined or null to disable this.
        */
    export function flush(maxRounds?: number): void;
}

declare module '__ts-events/lib/sync-event' {
    import baseEvent = require("__ts-events/lib/base-event");
    import BaseEvent = baseEvent.BaseEvent;
    /**
        * This is a true EventEmitter replacement: the handlers are called synchronously when
        * you post the event.
        * - Allows better error handling by aggregating any errors thrown by handlers.
        * - Prevents livelock by throwing an error when recursion depth is above a maximum.
        * - Handlers are called only for events posted after they were attached.
        * - Handlers are not called anymore when they are detached, even if a post() is in progress
        */
    export class SyncEvent<T> extends BaseEvent<T> {
            /**
                * Maximum number of times that an event handler may cause the same event
                * recursively.
                */
            static MAX_RECURSION_DEPTH: number;
            /**
                * Send the event. Handlers are called immediately and synchronously.
                * If an error is thrown by a handler, the remaining handlers are still called.
                * Afterward, an AggregateError is thrown with the original error(s) in its 'causes' property.
                */
            post(data: T): void;
    }
    /**
        * Convenience class for events without data
        */
    export class VoidSyncEvent extends SyncEvent<void> {
            /**
                * Send the event.
                */
            post(): void;
    }
    /**
        * Similar to "error" event on EventEmitter: throws when a post() occurs while no handlers set.
        */
    export class ErrorSyncEvent extends SyncEvent<Error> {
            post(data: Error): void;
    }
}

declare module '__ts-events/lib/queued-event' {
    import EventQueue = require("__ts-events/lib/EventQueue");
    import baseEvent = require("__ts-events/lib/base-event");
    import BaseEvent = baseEvent.BaseEvent;
    /**
        * Options for the QueuedEvent constructor
        */
    export interface QueuedEventOpts {
            /**
                * Condense multiple calls to post() into one.
                */
            condensed?: boolean;
            /**
                * Specific event queue to use. If not provided, the global instance is used.
                */
            queue?: EventQueue;
    }
    /**
        * Event that stays in a queue until you process the queue. Allows fine-grained
        * control over when events happen.
        * - Optionally condenses multiple post() calls into one.
        * - Handlers are called only for events posted after they were attached.
        * - Handlers are not called anymore when they are detached, even if a post() is in progress
        */
    export class QueuedEvent<T> extends BaseEvent<T> {
            /**
                * Constructor
                * @param opts Optional, an object with the following members:
                *             - condensed: a Boolean indicating whether to condense multiple calls to post() into one (default false)
                *             - queue: a specific event queue to use. The global EventQueue instance is used if not given.
                */
            constructor(opts?: QueuedEventOpts);
            /**
             * Send the event. Events are queued in the event queue until flushed out.
             * If the 'condensed' option was given in the constructor, multiple posts()
             * between queue flushes are condensed into one call with the data from the
             * last post() call.
             */
            post(data: T): void;
    }
    /**
        * Convenience class for events without data
        */
    export class VoidQueuedEvent extends QueuedEvent<void> {
            /**
                * Send the event.
                */
            post(): void;
    }
    /**
        * Similar to "error" event on EventEmitter: throws when a post() occurs while no handlers set.
        */
    export class ErrorQueuedEvent extends QueuedEvent<Error> {
            post(data: Error): void;
    }
}

declare module '__ts-events/lib/async-event' {
    import baseEvent = require("__ts-events/lib/base-event");
    import BaseEvent = baseEvent.BaseEvent;
    /**
        * Options for the AsyncEvent constructor
        */
    export interface AsyncEventOpts {
            /**
                * Condense multiple calls to post() into one while the previous one
                * has not been handled yet.
                */
            condensed?: boolean;
    }
    /**
        * A-synchronous event. Handlers are called in the next Node.JS cycle.
        * - Optionally condenses multiple post() calls into one (the last post() gets through)
        * - Handlers are called only for events posted after they were attached.
        * - Handlers are not called anymore when they are detached, even if a post() is in progress
        */
    export class AsyncEvent<T> extends BaseEvent<T> {
            /**
                * The default scheduler uses setImmediate() or setTimeout(..., 0) if setImmediate is not available.
                */
            static defaultScheduler(callback: () => void): void;
            /**
                * By default, AsyncEvent uses setImmediate() to schedule event handler invocation.
                * You can change this for e.g. setTimeout(..., 0) by calling this static method once.
                * @param scheduler A function that takes a callback and executes it in the next Node.JS cycle.
                */
            static setScheduler(scheduler: (callback: () => void) => void): void;
            /**
                * Constructor
                * @param opts Optional. Various settings:
                *             - condensed: a Boolean indicating whether to condense multiple post() calls within the same cycle.
                */
            constructor(opts?: AsyncEventOpts);
            /**
                * Send the AsyncEvent. Handlers are called in the next Node.JS cycle.
                */
            post(data: T): void;
    }
    /**
        * Convenience class for AsyncEvents without data
        */
    export class VoidAsyncEvent extends AsyncEvent<void> {
            /**
                * Send the AsyncEvent.
                */
            post(): void;
    }
    /**
        * Similar to "error" event on EventEmitter: throws when a post() occurs while no handlers set.
        */
    export class ErrorAsyncEvent extends AsyncEvent<Error> {
            post(data: Error): void;
    }
}

declare module '__ts-events/lib/EventQueue' {
    /**
        * Simple synchronous event queue that needs to be drained manually.
        */
    class EventQueue {
            /**
                * The module-global event queue
                */
            static global(): EventQueue;
            /**
                * Testing purposes
                */
            static resetGlobal(): void;
            /**
                * Add an element to the queue. The handler is called when one of the flush
                * methods is called.
                */
            add(handler: () => void): void;
            /**
                * Calls all handlers currently in the queue. Does not call any handlers added
                * as a result of the flush
                */
            flushOnce(): void;
            /**
                * Flushes the QueuedEvents, calling all events currently in the queue and those
                * put into the queue as a result of the flush.
                * @param maxRounds Optional, default 10. Number of iterations after which to throw an error because
                *                  the queue keeps filling up. Set to null to disable this.
                */
            flush(maxRounds?: number): void;
    }
    export = EventQueue;
}

declare module '__ts-events/lib/base-event' {
    export interface Listener<T> {
            deleted: boolean;
            handler: (data: T) => void;
            boundTo: Object;
    }
    export class BaseEvent<T> {
            /**
                * Attach an event handler
                * @param handler The function to call. The this argument of the function will be this object.
                */
            attach(handler: (data: T) => void): void;
            /**
                * Attach an event handler
                * @param boundTo The this argument of the handler
                * @param handler The function to call.
                */
            attach(boundTo: Object, handler: (data: T) => void): void;
            /**
                * Detach all listeners with the given handler function
                */
            detach(handler: (data: T) => void): void;
            /**
                * Detach all listeners with the given handler function and boundTo object.
                */
            detach(boundTo: Object, handler: (data: T) => void): void;
            /**
                * Detach all listeners that were attached with the given boundTo object.
                */
            detach(boundTo: Object): void;
            /**
                * Detach all listeners
                */
            detach(): void;
            listenerCount(): number;
            protected _copyListeners(): Listener<T>[];
    }
}

