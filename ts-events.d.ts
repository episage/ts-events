// Generated by dts-bundle v0.2.0

declare module 'ts-events' {
    import * as syncEvent from "./lib/sync-event";
    export import SyncEvent = syncEvent.SyncEvent;
    export import VoidSyncEvent = syncEvent.VoidSyncEvent;
    export import ErrorSyncEvent = syncEvent.ErrorSyncEvent;
    import * as queuedEvent from "./lib/queued-event";
    export import QueuedEvent = queuedEvent.QueuedEvent;
    export import VoidQueuedEvent = queuedEvent.VoidQueuedEvent;
    export import ErrorQueuedEvent = queuedEvent.ErrorQueuedEvent;
    import * as asyncEvent from "./lib/async-event";
    export import AsyncEvent = asyncEvent.AsyncEvent;
    export import VoidAsyncEvent = asyncEvent.VoidAsyncEvent;
    export import ErrorAsyncEvent = asyncEvent.ErrorAsyncEvent;
    export import EventQueue = require("__ts-events/lib/EventQueue");
    import * as anyEvent from "./lib/any-event";
    export import AnyEvent = anyEvent.AnyEvent;
    export import VoidAnyEvent = anyEvent.VoidAnyEvent;
    export import ErrorAnyEvent = anyEvent.ErrorAnyEvent;
    /**
        * The global event queue for QueuedEvents
        */
    export function queue(): EventQueue;
    /**
        * Convenience function, same as EventQueue.global().flushOnce().
        * Flushes the QueuedEvents, calling all events currently in the queue but not
        * any events put into the queue as a result of the flush.
        */
    export function flushOnce(): void;
    /**
        * Convenience function, same as EventQueue.global().flush().
        * Flushes the QueuedEvents, calling all handlers currently in the queue and those
        * put into the queue as a result of the flush.
        * @param maxRounds Optional, default 10. Number of iterations after which to throw an error because
        *                  the queue keeps filling up. Set to undefined or null to disable this.
        */
    export function flush(maxRounds?: number): void;
}

declare module '__ts-events/lib/EventQueue' {
    import syncEvent = require("__ts-events/lib/sync-event");
    import SyncEvent = syncEvent.SyncEvent;
    /**
        * Simple synchronous event queue that needs to be drained manually.
        */
    class EventQueue {
            /**
                * SyncEvent triggered after an event is added outside of a flush operation.
                * @param queue The event queue itself
                */
            evtFilled: SyncEvent<EventQueue>;
            /**
                * SyncEvent triggered after the queue is flushed empty
                * @param queue The event queue itself
                */
            evtDrained: SyncEvent<EventQueue>;
            /**
                * The module-global event queue
                */
            static global(): EventQueue;
            /**
                * Testing purposes
                */
            static resetGlobal(): void;
            /**
                * Returns true iff the queue is empty
                */
            empty(): boolean;
            /**
                * Add an element to the queue. The handler is called when one of the flush
                * methods is called.
                */
            add(handler: () => void): void;
            /**
                * Calls all handlers currently in the queue. Does not call any handlers added
                * as a result of the flush
                */
            flushOnce(): void;
            /**
                * Flushes the QueuedEvents, calling all events currently in the queue and those
                * put into the queue as a result of the flush.
                * @param maxRounds Optional, default 10. Number of iterations after which to throw an error because
                *                  the queue keeps filling up. Set to null to disable this.
                */
            flush(maxRounds?: number): void;
    }
    export = EventQueue;
}

declare module '__ts-events/lib/sync-event' {
    import baseEvent = require("__ts-events/lib/base-event");
    import BaseEvent = baseEvent.BaseEvent;
    import Postable = baseEvent.Postable;
    /**
        * This is a true EventEmitter replacement: the handlers are called synchronously when
        * you post the event.
        * - Allows better error handling by aggregating any errors thrown by handlers.
        * - Prevents livelock by throwing an error when recursion depth is above a maximum.
        * - Handlers are called only for events posted after they were attached.
        * - Handlers are not called anymore when they are detached, even if a post() is in progress
        */
    export class SyncEvent<T> extends BaseEvent<T> implements Postable<T> {
            /**
                * Maximum number of times that an event handler may cause the same event
                * recursively.
                */
            static MAX_RECURSION_DEPTH: number;
            /**
                * Send the event. Handlers are called immediately and synchronously.
                * If an error is thrown by a handler, the remaining handlers are still called.
                * Afterward, an AggregateError is thrown with the original error(s) in its 'causes' property.
                */
            post(data: T): void;
    }
    /**
        * Convenience class for events without data
        */
    export class VoidSyncEvent extends SyncEvent<void> {
            /**
                * Send the event.
                */
            post(): void;
    }
    /**
        * Similar to "error" event on EventEmitter: throws when a post() occurs while no handlers set.
        */
    export class ErrorSyncEvent extends SyncEvent<Error> {
            post(data: Error): void;
    }
}

declare module '__ts-events/lib/base-event' {
    export interface Postable<T> {
            post(data: T): void;
    }
    /**
        * Internal interface between BaseEvent and its subclasses
        */
    export interface Listener<T> {
            /**
                * Indicates that the listener was detached
                */
            deleted: boolean;
            /**
                * The handler
                */
            handler?: (data: T) => void;
            /**
                * The this pointer for the handler
                */
            boundTo?: Object;
            /**
                * Instead of a handler, an attached event
                */
            event?: Postable<T>;
    }
    /**
        * Base class for events.
        * Handles attaching and detaching listeners
        */
    export class BaseEvent<T> implements Postable<T> {
            /**
                * Attached listeners. NOTE: do not modify.
                * Instead, replace with a new array with possibly the same elements. This ensures
                * that any references to the array by events that are underway remain the same.
                */
            protected _listeners: Listener<T>[];
            /**
                * Attach an event handler
                * @param handler The function to call. The this argument of the function will be this object.
                */
            attach(handler: (data: T) => void): void;
            /**
                * Attach an event handler
                * @param boundTo The this argument of the handler
                * @param handler The function to call.
                */
            attach(boundTo: Object, handler: (data: T) => void): void;
            /**
                * Attach an event directly
                * @param event The event to be posted
                */
            attach(event: Postable<T>): void;
            /**
                * Detach all listeners with the given handler function
                */
            detach(handler: (data: T) => void): void;
            /**
                * Detach all listeners with the given handler function and boundTo object.
                */
            detach(boundTo: Object, handler: (data: T) => void): void;
            /**
                * Detach all listeners that were attached with the given boundTo object.
                */
            detach(boundTo: Object): void;
            /**
                * Detach the given event.
                */
            detach(event: Postable<T>): void;
            /**
                * Detach all listeners
                */
            detach(): void;
            /**
                * Abstract post() method to be able to connect any type of event to any other directly
                * @abstract
                */
            post(data: T): void;
            /**
                * The number of attached listeners
                */
            listenerCount(): number;
            /**
                * Call the given listener, if it is not marked as 'deleted'
                * @param listener The listener to call
                * @param args The arguments to the handler
                */
            protected _call(listener: Listener<T>, args: any[]): void;
    }
}

